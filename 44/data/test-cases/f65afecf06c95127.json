{"uid":"f65afecf06c95127","name":"Редактирование категории","fullName":"tests.ui_tests.test_profile#test_edit_category","historyId":"2683b161841400ea3087b07c0cddf4ee","time":{"start":1771689219938,"stop":1771689219938,"duration":0},"status":"broken","statusMessage":"sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation \"user\" does not exist\nLINE 2: FROM \"user\" \n             ^\n\n[SQL: SELECT \"user\".id, \"user\".username, \"user\".currency, \"user\".firstname, \"user\".surname, \"user\".photo, \"user\".photo_small \nFROM \"user\" \nWHERE \"user\".username = %(username_1)s]\n[parameters: {'username_1': 'Alex'}]\n(Background on this error at: https://sqlalche.me/e/20/f405)","statusTrace":"self = <sqlalchemy.engine.base.Connection object at 0x7fbfa7568b20>\ndialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fbfa6c98070>\ncontext = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fbfa671f880>\nstatement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fbfa758c340>\nparameters = [{'username_1': 'Alex'}]\n\n    def _exec_single_context(\n        self,\n        dialect: Dialect,\n        context: ExecutionContext,\n        statement: Union[str, Compiled],\n        parameters: Optional[_AnyMultiExecuteParams],\n    ) -> CursorResult[Any]:\n        \"\"\"continue the _execute_context() method for a single DBAPI\n        cursor.execute() or cursor.executemany() call.\n    \n        \"\"\"\n        if dialect.bind_typing is BindTyping.SETINPUTSIZES:\n            generic_setinputsizes = context._prepare_set_input_sizes()\n    \n            if generic_setinputsizes:\n                try:\n                    dialect.do_set_input_sizes(\n                        context.cursor, generic_setinputsizes, context\n                    )\n                except BaseException as e:\n                    self._handle_dbapi_exception(\n                        e, str(statement), parameters, None, context\n                    )\n    \n        cursor, str_statement, parameters = (\n            context.cursor,\n            context.statement,\n            context.parameters,\n        )\n    \n        effective_parameters: Optional[_AnyExecuteParams]\n    \n        if not context.executemany:\n            effective_parameters = parameters[0]\n        else:\n            effective_parameters = parameters\n    \n        if self._has_events or self.engine._has_events:\n            for fn in self.dispatch.before_cursor_execute:\n                str_statement, effective_parameters = fn(\n                    self,\n                    cursor,\n                    str_statement,\n                    effective_parameters,\n                    context,\n                    context.executemany,\n                )\n    \n        if self._echo:\n            self._log_info(str_statement)\n    \n            stats = context._get_cache_stats()\n    \n            if not self.engine.hide_parameters:\n                self._log_info(\n                    \"[%s] %r\",\n                    stats,\n                    sql_util._repr_params(\n                        effective_parameters,\n                        batches=10,\n                        ismulti=context.executemany,\n                    ),\n                )\n            else:\n                self._log_info(\n                    \"[%s] [SQL parameters hidden due to hide_parameters=True]\",\n                    stats,\n                )\n    \n        evt_handled: bool = False\n        try:\n            if context.execute_style is ExecuteStyle.EXECUTEMANY:\n                effective_parameters = cast(\n                    \"_CoreMultiExecuteParams\", effective_parameters\n                )\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_executemany:\n                        if fn(\n                            cursor,\n                            str_statement,\n                            effective_parameters,\n                            context,\n                        ):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_executemany(\n                        cursor,\n                        str_statement,\n                        effective_parameters,\n                        context,\n                    )\n            elif not effective_parameters and context.no_parameters:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute_no_params:\n                        if fn(cursor, str_statement, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_execute_no_params(\n                        cursor, str_statement, context\n                    )\n            else:\n                effective_parameters = cast(\n                    \"_CoreSingleExecuteParams\", effective_parameters\n                )\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute:\n                        if fn(\n                            cursor,\n                            str_statement,\n                            effective_parameters,\n                            context,\n                        ):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n>                   self.dialect.do_execute(\n                        cursor, str_statement, effective_parameters, context\n                    )\n\n.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1967: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fbfa6c98070>\ncursor = <cursor object at 0x7fbfa69b1d50; closed: -1>\nstatement = 'SELECT \"user\".id, \"user\".username, \"user\".currency, \"user\".firstname, \"user\".surname, \"user\".photo, \"user\".photo_small \\nFROM \"user\" \\nWHERE \"user\".username = %(username_1)s'\nparameters = {'username_1': 'Alex'}\ncontext = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fbfa671f880>\n\n    def do_execute(self, cursor, statement, parameters, context=None):\n>       cursor.execute(statement, parameters)\nE       psycopg2.errors.UndefinedTable: relation \"user\" does not exist\nE       LINE 2: FROM \"user\" \nE                    ^\n\n.venv/lib/python3.10/site-packages/sqlalchemy/engine/default.py:951: UndefinedTable\n\nThe above exception was the direct cause of the following exception:\n\nenvs = Envs(frontend_url='http://frontend.niffler.dc', gateway_url='http://gateway.niffler.dc:8090', spend_db_url='postgresql...trap_servers='localhost:9093', userdata_db_url='postgresql+psycopg2://postgres:secret@localhost:5432/niffler-userdata')\nuser_db = <database.user_db.UserDb object at 0x7fbfa6e89270>\nauth_client = <clients.oauth_client.OAuthClient object at 0x7fbfa756a650>\n\n    @pytest.fixture(scope=\"session\", autouse=True)\n    def registration_user(envs: Envs, user_db, auth_client):\n>       user = user_db.get_user_by_username(envs.username)\n\nconftest.py:168: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <database.user_db.UserDb object at 0x7fbfa6e89270>, username = 'Alex'\n\n    def get_user_by_username(self, username: str):\n        with Session(self.engine) as session:\n            user = select(User).where(User.username == username)\n>           return session.exec(user).first()\n\ndatabase/user_db.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlmodel.orm.session.Session object at 0x7fbfa756b400>\nstatement = <sqlmodel.sql._expression_select_cls.SelectOfScalar object at 0x7fbfa7568a00>\n\n    def exec(\n        self,\n        statement: Union[\n            Select[_TSelectParam],\n            SelectOfScalar[_TSelectParam],\n            Executable[_TSelectParam],\n            UpdateBase,\n        ],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Dict[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n    ) -> Union[\n        TupleResult[_TSelectParam], ScalarResult[_TSelectParam], CursorResult[Any]\n    ]:\n>       results = super().execute(\n            statement,\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n        )\n\n.venv/lib/python3.10/site-packages/sqlmodel/orm/session.py:83: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlmodel.orm.session.Session object at 0x7fbfa756b400>\nstatement = <sqlmodel.sql._expression_select_cls.SelectOfScalar object at 0x7fbfa7568a00>\nparams = None\n\n    def execute(\n        self,\n        statement: Executable,\n        params: Optional[_CoreAnyExecuteParams] = None,\n        *,\n        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,\n        bind_arguments: Optional[_BindArguments] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n    ) -> Result[Any]:\n        r\"\"\"Execute a SQL expression construct.\n    \n        Returns a :class:`_engine.Result` object representing\n        results of the statement execution.\n    \n        E.g.::\n    \n            from sqlalchemy import select\n    \n            result = session.execute(select(User).where(User.id == 5))\n    \n        The API contract of :meth:`_orm.Session.execute` is similar to that\n        of :meth:`_engine.Connection.execute`, the :term:`2.0 style` version\n        of :class:`_engine.Connection`.\n    \n        .. versionchanged:: 1.4 the :meth:`_orm.Session.execute` method is\n           now the primary point of ORM statement execution when using\n           :term:`2.0 style` ORM usage.\n    \n        :param statement:\n            An executable statement (i.e. an :class:`.Executable` expression\n            such as :func:`_expression.select`).\n    \n        :param params:\n            Optional dictionary, or list of dictionaries, containing\n            bound parameter values.   If a single dictionary, single-row\n            execution occurs; if a list of dictionaries, an\n            \"executemany\" will be invoked.  The keys in each dictionary\n            must correspond to parameter names present in the statement.\n    \n        :param execution_options: optional dictionary of execution options,\n         which will be associated with the statement execution.  This\n         dictionary can provide a subset of the options that are accepted\n         by :meth:`_engine.Connection.execution_options`, and may also\n         provide additional options understood only in an ORM context.\n    \n         .. seealso::\n    \n            :ref:`orm_queryguide_execution_options` - ORM-specific execution\n            options\n    \n        :param bind_arguments: dictionary of additional arguments to determine\n         the bind.  May include \"mapper\", \"bind\", or other custom arguments.\n         Contents of this dictionary are passed to the\n         :meth:`.Session.get_bind` method.\n    \n        :return: a :class:`_engine.Result` object.\n    \n    \n        \"\"\"\n>       return self._execute_internal(\n            statement,\n            params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n        )\n\n.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2351: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlmodel.orm.session.Session object at 0x7fbfa756b400>\nstatement = <sqlmodel.sql._expression_select_cls.SelectOfScalar object at 0x7fbfa7568a00>\nparams = None\n\n    def _execute_internal(\n        self,\n        statement: Executable,\n        params: Optional[_CoreAnyExecuteParams] = None,\n        *,\n        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,\n        bind_arguments: Optional[_BindArguments] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        _scalar_result: bool = False,\n    ) -> Any:\n        statement = coercions.expect(roles.StatementRole, statement)\n    \n        if not bind_arguments:\n            bind_arguments = {}\n        else:\n            bind_arguments = dict(bind_arguments)\n    \n        if (\n            statement._propagate_attrs.get(\"compile_state_plugin\", None)\n            == \"orm\"\n        ):\n            compile_state_cls = CompileState._get_plugin_class_for_plugin(\n                statement, \"orm\"\n            )\n            if TYPE_CHECKING:\n                assert isinstance(\n                    compile_state_cls, context.AbstractORMCompileState\n                )\n        else:\n            compile_state_cls = None\n            bind_arguments.setdefault(\"clause\", statement)\n    \n        execution_options = util.coerce_to_immutabledict(execution_options)\n    \n        if _parent_execute_state:\n            events_todo = _parent_execute_state._remaining_events()\n        else:\n            events_todo = self.dispatch.do_orm_execute\n            if _add_event:\n                events_todo = list(events_todo) + [_add_event]\n    \n        if events_todo:\n            if compile_state_cls is not None:\n                # for event handlers, do the orm_pre_session_exec\n                # pass ahead of the event handlers, so that things like\n                # .load_options, .update_delete_options etc. are populated.\n                # is_pre_event=True allows the hook to hold off on things\n                # it doesn't want to do twice, including autoflush as well\n                # as \"pre fetch\" for DML, etc.\n                (\n                    statement,\n                    execution_options,\n                ) = compile_state_cls.orm_pre_session_exec(\n                    self,\n                    statement,\n                    params,\n                    execution_options,\n                    bind_arguments,\n                    True,\n                )\n    \n            orm_exec_state = ORMExecuteState(\n                self,\n                statement,\n                params,\n                execution_options,\n                bind_arguments,\n                compile_state_cls,\n                events_todo,\n            )\n            for idx, fn in enumerate(events_todo):\n                orm_exec_state._starting_event_idx = idx\n                fn_result: Optional[Result[Any]] = fn(orm_exec_state)\n                if fn_result:\n                    if _scalar_result:\n                        return fn_result.scalar()\n                    else:\n                        return fn_result\n    \n            statement = orm_exec_state.statement\n            execution_options = orm_exec_state.local_execution_options\n    \n        if compile_state_cls is not None:\n            # now run orm_pre_session_exec() \"for real\".   if there were\n            # event hooks, this will re-run the steps that interpret\n            # new execution_options into load_options / update_delete_options,\n            # which we assume the event hook might have updated.\n            # autoflush will also be invoked in this step if enabled.\n            (\n                statement,\n                execution_options,\n            ) = compile_state_cls.orm_pre_session_exec(\n                self,\n                statement,\n                params,\n                execution_options,\n                bind_arguments,\n                False,\n            )\n    \n        bind = self.get_bind(**bind_arguments)\n    \n        conn = self._connection_for_bind(bind)\n    \n        if _scalar_result and not compile_state_cls:\n            if TYPE_CHECKING:\n                params = cast(_CoreSingleExecuteParams, params)\n            return conn.scalar(\n                statement, params or {}, execution_options=execution_options\n            )\n    \n        if compile_state_cls:\n>           result: Result[Any] = compile_state_cls.orm_execute_statement(\n                self,\n                statement,\n                params or {},\n                execution_options,\n                bind_arguments,\n                conn,\n            )\n\n.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2249: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'sqlalchemy.orm.context.ORMSelectCompileState'>\nsession = <sqlmodel.orm.session.Session object at 0x7fbfa756b400>\nstatement = <sqlmodel.sql._expression_select_cls.SelectOfScalar object at 0x7fbfa7568a00>\nparams = {}\nexecution_options = immutabledict({'_result_disable_adapt_to_context': True})\nbind_arguments = {'clause': <sqlmodel.sql._expression_select_cls.SelectOfScalar object at 0x7fbfa7568a00>, 'mapper': <Mapper at 0x7fbfa759a3e0; User>}\nconn = <sqlalchemy.engine.base.Connection object at 0x7fbfa7568b20>\n\n    @classmethod\n    def orm_execute_statement(\n        cls,\n        session,\n        statement,\n        params,\n        execution_options,\n        bind_arguments,\n        conn,\n    ) -> Result:\n>       result = conn.execute(\n            statement, params or {}, execution_options=execution_options\n        )\n\n.venv/lib/python3.10/site-packages/sqlalchemy/orm/context.py:306: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.engine.base.Connection object at 0x7fbfa7568b20>\nstatement = <sqlmodel.sql._expression_select_cls.SelectOfScalar object at 0x7fbfa7568a00>\nparameters = {}\n\n    def execute(\n        self,\n        statement: Executable,\n        parameters: Optional[_CoreAnyExecuteParams] = None,\n        *,\n        execution_options: Optional[CoreExecuteOptionsParameter] = None,\n    ) -> CursorResult[Any]:\n        r\"\"\"Executes a SQL statement construct and returns a\n        :class:`_engine.CursorResult`.\n    \n        :param statement: The statement to be executed.  This is always\n         an object that is in both the :class:`_expression.ClauseElement` and\n         :class:`_expression.Executable` hierarchies, including:\n    \n         * :class:`_expression.Select`\n         * :class:`_expression.Insert`, :class:`_expression.Update`,\n           :class:`_expression.Delete`\n         * :class:`_expression.TextClause` and\n           :class:`_expression.TextualSelect`\n         * :class:`_schema.DDL` and objects which inherit from\n           :class:`_schema.ExecutableDDLElement`\n    \n        :param parameters: parameters which will be bound into the statement.\n         This may be either a dictionary of parameter names to values,\n         or a mutable sequence (e.g. a list) of dictionaries.  When a\n         list of dictionaries is passed, the underlying statement execution\n         will make use of the DBAPI ``cursor.executemany()`` method.\n         When a single dictionary is passed, the DBAPI ``cursor.execute()``\n         method will be used.\n    \n        :param execution_options: optional dictionary of execution options,\n         which will be associated with the statement execution.  This\n         dictionary can provide a subset of the options that are accepted\n         by :meth:`_engine.Connection.execution_options`.\n    \n        :return: a :class:`_engine.Result` object.\n    \n        \"\"\"\n        distilled_parameters = _distill_params_20(parameters)\n        try:\n            meth = statement._execute_on_connection\n        except AttributeError as err:\n            raise exc.ObjectNotExecutableError(statement) from err\n        else:\n>           return meth(\n                self,\n                distilled_parameters,\n                execution_options or NO_OPTIONS,\n            )\n\n.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1419: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlmodel.sql._expression_select_cls.SelectOfScalar object at 0x7fbfa7568a00>\nconnection = <sqlalchemy.engine.base.Connection object at 0x7fbfa7568b20>\ndistilled_params = [{}]\nexecution_options = immutabledict({'_result_disable_adapt_to_context': True})\n\n    def _execute_on_connection(\n        self,\n        connection: Connection,\n        distilled_params: _CoreMultiExecuteParams,\n        execution_options: CoreExecuteOptionsParameter,\n    ) -> Result[Any]:\n        if self.supports_execution:\n            if TYPE_CHECKING:\n                assert isinstance(self, Executable)\n>           return connection._execute_clauseelement(\n                self, distilled_params, execution_options\n            )\n\n.venv/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:526: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.engine.base.Connection object at 0x7fbfa7568b20>\nelem = <sqlmodel.sql._expression_select_cls.SelectOfScalar object at 0x7fbfa7568a00>\ndistilled_parameters = [{}]\nexecution_options = immutabledict({'_result_disable_adapt_to_context': True})\n\n    def _execute_clauseelement(\n        self,\n        elem: Executable,\n        distilled_parameters: _CoreMultiExecuteParams,\n        execution_options: CoreExecuteOptionsParameter,\n    ) -> CursorResult[Any]:\n        \"\"\"Execute a sql.ClauseElement object.\"\"\"\n    \n        execution_options = elem._execution_options.merge_with(\n            self._execution_options, execution_options\n        )\n    \n        has_events = self._has_events or self.engine._has_events\n        if has_events:\n            (\n                elem,\n                distilled_parameters,\n                event_multiparams,\n                event_params,\n            ) = self._invoke_before_exec_event(\n                elem, distilled_parameters, execution_options\n            )\n    \n        if distilled_parameters:\n            # ensure we don't retain a link to the view object for keys()\n            # which links to the values, which we don't want to cache\n            keys = sorted(distilled_parameters[0])\n            for_executemany = len(distilled_parameters) > 1\n        else:\n            keys = []\n            for_executemany = False\n    \n        dialect = self.dialect\n    \n        schema_translate_map = execution_options.get(\n            \"schema_translate_map\", None\n        )\n    \n        compiled_cache: Optional[CompiledCacheType] = execution_options.get(\n            \"compiled_cache\", self.engine._compiled_cache\n        )\n    \n        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(\n            dialect=dialect,\n            compiled_cache=compiled_cache,\n            column_keys=keys,\n            for_executemany=for_executemany,\n            schema_translate_map=schema_translate_map,\n            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,\n        )\n>       ret = self._execute_context(\n            dialect,\n            dialect.execution_ctx_cls._init_compiled,\n            compiled_sql,\n            distilled_parameters,\n            execution_options,\n            compiled_sql,\n            distilled_parameters,\n            elem,\n            extracted_params,\n            cache_hit=cache_hit,\n        )\n\n.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1641: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.engine.base.Connection object at 0x7fbfa7568b20>\ndialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fbfa6c98070>\nconstructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2'>>\nstatement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fbfa758c340>\nparameters = [{}]\nexecution_options = immutabledict({'_result_disable_adapt_to_context': True})\nargs = (<sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fbfa758c340>, [{}], <sqlmodel.sql._expression_select_cls.SelectOfScalar object at 0x7fbfa7568a00>, [BindParameter('%(140461122948016 username)s', 'Alex', type_=AutoString())])\nkw = {'cache_hit': <CacheStats.CACHE_MISS: 1>}, yp = None\nconn = <sqlalchemy.pool.base._ConnectionFairy object at 0x7fbfa63f4880>\ncontext = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fbfa671f880>\n\n    def _execute_context(\n        self,\n        dialect: Dialect,\n        constructor: Callable[..., ExecutionContext],\n        statement: Union[str, Compiled],\n        parameters: Optional[_AnyMultiExecuteParams],\n        execution_options: _ExecuteOptions,\n        *args: Any,\n        **kw: Any,\n    ) -> CursorResult[Any]:\n        \"\"\"Create an :class:`.ExecutionContext` and execute, returning\n        a :class:`_engine.CursorResult`.\"\"\"\n    \n        if execution_options:\n            yp = execution_options.get(\"yield_per\", None)\n            if yp:\n                execution_options = execution_options.union(\n                    {\"stream_results\": True, \"max_row_buffer\": yp}\n                )\n        try:\n            conn = self._dbapi_connection\n            if conn is None:\n                conn = self._revalidate_connection()\n    \n            context = constructor(\n                dialect, self, conn, execution_options, *args, **kw\n            )\n        except (exc.PendingRollbackError, exc.ResourceClosedError):\n            raise\n        except BaseException as e:\n            self._handle_dbapi_exception(\n                e, str(statement), parameters, None, None\n            )\n    \n        if (\n            self._transaction\n            and not self._transaction.is_active\n            or (\n                self._nested_transaction\n                and not self._nested_transaction.is_active\n            )\n        ):\n            self._invalid_transaction()\n    \n        elif self._trans_context_manager:\n            TransactionalContext._trans_ctx_check(self)\n    \n        if self._transaction is None:\n            self._autobegin()\n    \n        context.pre_exec()\n    \n        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:\n            return self._exec_insertmany_context(dialect, context)\n        else:\n>           return self._exec_single_context(\n                dialect, context, statement, parameters\n            )\n\n.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1846: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.engine.base.Connection object at 0x7fbfa7568b20>\ndialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fbfa6c98070>\ncontext = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fbfa671f880>\nstatement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fbfa758c340>\nparameters = [{'username_1': 'Alex'}]\n\n    def _exec_single_context(\n        self,\n        dialect: Dialect,\n        context: ExecutionContext,\n        statement: Union[str, Compiled],\n        parameters: Optional[_AnyMultiExecuteParams],\n    ) -> CursorResult[Any]:\n        \"\"\"continue the _execute_context() method for a single DBAPI\n        cursor.execute() or cursor.executemany() call.\n    \n        \"\"\"\n        if dialect.bind_typing is BindTyping.SETINPUTSIZES:\n            generic_setinputsizes = context._prepare_set_input_sizes()\n    \n            if generic_setinputsizes:\n                try:\n                    dialect.do_set_input_sizes(\n                        context.cursor, generic_setinputsizes, context\n                    )\n                except BaseException as e:\n                    self._handle_dbapi_exception(\n                        e, str(statement), parameters, None, context\n                    )\n    \n        cursor, str_statement, parameters = (\n            context.cursor,\n            context.statement,\n            context.parameters,\n        )\n    \n        effective_parameters: Optional[_AnyExecuteParams]\n    \n        if not context.executemany:\n            effective_parameters = parameters[0]\n        else:\n            effective_parameters = parameters\n    \n        if self._has_events or self.engine._has_events:\n            for fn in self.dispatch.before_cursor_execute:\n                str_statement, effective_parameters = fn(\n                    self,\n                    cursor,\n                    str_statement,\n                    effective_parameters,\n                    context,\n                    context.executemany,\n                )\n    \n        if self._echo:\n            self._log_info(str_statement)\n    \n            stats = context._get_cache_stats()\n    \n            if not self.engine.hide_parameters:\n                self._log_info(\n                    \"[%s] %r\",\n                    stats,\n                    sql_util._repr_params(\n                        effective_parameters,\n                        batches=10,\n                        ismulti=context.executemany,\n                    ),\n                )\n            else:\n                self._log_info(\n                    \"[%s] [SQL parameters hidden due to hide_parameters=True]\",\n                    stats,\n                )\n    \n        evt_handled: bool = False\n        try:\n            if context.execute_style is ExecuteStyle.EXECUTEMANY:\n                effective_parameters = cast(\n                    \"_CoreMultiExecuteParams\", effective_parameters\n                )\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_executemany:\n                        if fn(\n                            cursor,\n                            str_statement,\n                            effective_parameters,\n                            context,\n                        ):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_executemany(\n                        cursor,\n                        str_statement,\n                        effective_parameters,\n                        context,\n                    )\n            elif not effective_parameters and context.no_parameters:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute_no_params:\n                        if fn(cursor, str_statement, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_execute_no_params(\n                        cursor, str_statement, context\n                    )\n            else:\n                effective_parameters = cast(\n                    \"_CoreSingleExecuteParams\", effective_parameters\n                )\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute:\n                        if fn(\n                            cursor,\n                            str_statement,\n                            effective_parameters,\n                            context,\n                        ):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_execute(\n                        cursor, str_statement, effective_parameters, context\n                    )\n    \n            if self._has_events or self.engine._has_events:\n                self.dispatch.after_cursor_execute(\n                    self,\n                    cursor,\n                    str_statement,\n                    effective_parameters,\n                    context,\n                    context.executemany,\n                )\n    \n            context.post_exec()\n    \n            result = context._setup_result_proxy()\n    \n        except BaseException as e:\n>           self._handle_dbapi_exception(\n                e, str_statement, effective_parameters, cursor, context\n            )\n\n.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1986: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.engine.base.Connection object at 0x7fbfa7568b20>\ne = UndefinedTable('relation \"user\" does not exist\\nLINE 2: FROM \"user\" \\n             ^\\n')\nstatement = 'SELECT \"user\".id, \"user\".username, \"user\".currency, \"user\".firstname, \"user\".surname, \"user\".photo, \"user\".photo_small \\nFROM \"user\" \\nWHERE \"user\".username = %(username_1)s'\nparameters = {'username_1': 'Alex'}\ncursor = <cursor object at 0x7fbfa69b1d50; closed: -1>\ncontext = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fbfa671f880>\nis_sub_exec = False\n\n    def _handle_dbapi_exception(\n        self,\n        e: BaseException,\n        statement: Optional[str],\n        parameters: Optional[_AnyExecuteParams],\n        cursor: Optional[DBAPICursor],\n        context: Optional[ExecutionContext],\n        is_sub_exec: bool = False,\n    ) -> NoReturn:\n        exc_info = sys.exc_info()\n    \n        is_exit_exception = util.is_exit_exception(e)\n    \n        if not self._is_disconnect:\n            self._is_disconnect = (\n                isinstance(e, self.dialect.loaded_dbapi.Error)\n                and not self.closed\n                and self.dialect.is_disconnect(\n                    e,\n                    self._dbapi_connection if not self.invalidated else None,\n                    cursor,\n                )\n            ) or (is_exit_exception and not self.closed)\n    \n        invalidate_pool_on_disconnect = not is_exit_exception\n    \n        ismulti: bool = (\n            not is_sub_exec and context.executemany\n            if context is not None\n            else False\n        )\n        if self._reentrant_error:\n            raise exc.DBAPIError.instance(\n                statement,\n                parameters,\n                e,\n                self.dialect.loaded_dbapi.Error,\n                hide_parameters=self.engine.hide_parameters,\n                dialect=self.dialect,\n                ismulti=ismulti,\n            ).with_traceback(exc_info[2]) from e\n        self._reentrant_error = True\n        try:\n            # non-DBAPI error - if we already got a context,\n            # or there's no string statement, don't wrap it\n            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (\n                statement is not None\n                and context is None\n                and not is_exit_exception\n            )\n    \n            if should_wrap:\n                sqlalchemy_exception = exc.DBAPIError.instance(\n                    statement,\n                    parameters,\n                    cast(Exception, e),\n                    self.dialect.loaded_dbapi.Error,\n                    hide_parameters=self.engine.hide_parameters,\n                    connection_invalidated=self._is_disconnect,\n                    dialect=self.dialect,\n                    ismulti=ismulti,\n                )\n            else:\n                sqlalchemy_exception = None\n    \n            newraise = None\n    \n            if (self.dialect._has_events) and not self._execution_options.get(\n                \"skip_user_error_events\", False\n            ):\n                ctx = ExceptionContextImpl(\n                    e,\n                    sqlalchemy_exception,\n                    self.engine,\n                    self.dialect,\n                    self,\n                    cursor,\n                    statement,\n                    parameters,\n                    context,\n                    self._is_disconnect,\n                    invalidate_pool_on_disconnect,\n                    False,\n                )\n    \n                for fn in self.dialect.dispatch.handle_error:\n                    try:\n                        # handler returns an exception;\n                        # call next handler in a chain\n                        per_fn = fn(ctx)\n                        if per_fn is not None:\n                            ctx.chained_exception = newraise = per_fn\n                    except Exception as _raised:\n                        # handler raises an exception - stop processing\n                        newraise = _raised\n                        break\n    \n                if self._is_disconnect != ctx.is_disconnect:\n                    self._is_disconnect = ctx.is_disconnect\n                    if sqlalchemy_exception:\n                        sqlalchemy_exception.connection_invalidated = (\n                            ctx.is_disconnect\n                        )\n    \n                # set up potentially user-defined value for\n                # invalidate pool.\n                invalidate_pool_on_disconnect = (\n                    ctx.invalidate_pool_on_disconnect\n                )\n    \n            if should_wrap and context:\n                context.handle_dbapi_exception(e)\n    \n            if not self._is_disconnect:\n                if cursor:\n                    self._safe_close_cursor(cursor)\n                # \"autorollback\" was mostly relevant in 1.x series.\n                # It's very unlikely to reach here, as the connection\n                # does autobegin so when we are here, we are usually\n                # in an explicit / semi-explicit transaction.\n                # however we have a test which manufactures this\n                # scenario in any case using an event handler.\n                # test/engine/test_execute.py-> test_actual_autorollback\n                if not self.in_transaction():\n                    self._rollback_impl()\n    \n            if newraise:\n                raise newraise.with_traceback(exc_info[2]) from e\n            elif should_wrap:\n                assert sqlalchemy_exception is not None\n>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e\n\n.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2355: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.engine.base.Connection object at 0x7fbfa7568b20>\ndialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fbfa6c98070>\ncontext = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fbfa671f880>\nstatement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fbfa758c340>\nparameters = [{'username_1': 'Alex'}]\n\n    def _exec_single_context(\n        self,\n        dialect: Dialect,\n        context: ExecutionContext,\n        statement: Union[str, Compiled],\n        parameters: Optional[_AnyMultiExecuteParams],\n    ) -> CursorResult[Any]:\n        \"\"\"continue the _execute_context() method for a single DBAPI\n        cursor.execute() or cursor.executemany() call.\n    \n        \"\"\"\n        if dialect.bind_typing is BindTyping.SETINPUTSIZES:\n            generic_setinputsizes = context._prepare_set_input_sizes()\n    \n            if generic_setinputsizes:\n                try:\n                    dialect.do_set_input_sizes(\n                        context.cursor, generic_setinputsizes, context\n                    )\n                except BaseException as e:\n                    self._handle_dbapi_exception(\n                        e, str(statement), parameters, None, context\n                    )\n    \n        cursor, str_statement, parameters = (\n            context.cursor,\n            context.statement,\n            context.parameters,\n        )\n    \n        effective_parameters: Optional[_AnyExecuteParams]\n    \n        if not context.executemany:\n            effective_parameters = parameters[0]\n        else:\n            effective_parameters = parameters\n    \n        if self._has_events or self.engine._has_events:\n            for fn in self.dispatch.before_cursor_execute:\n                str_statement, effective_parameters = fn(\n                    self,\n                    cursor,\n                    str_statement,\n                    effective_parameters,\n                    context,\n                    context.executemany,\n                )\n    \n        if self._echo:\n            self._log_info(str_statement)\n    \n            stats = context._get_cache_stats()\n    \n            if not self.engine.hide_parameters:\n                self._log_info(\n                    \"[%s] %r\",\n                    stats,\n                    sql_util._repr_params(\n                        effective_parameters,\n                        batches=10,\n                        ismulti=context.executemany,\n                    ),\n                )\n            else:\n                self._log_info(\n                    \"[%s] [SQL parameters hidden due to hide_parameters=True]\",\n                    stats,\n                )\n    \n        evt_handled: bool = False\n        try:\n            if context.execute_style is ExecuteStyle.EXECUTEMANY:\n                effective_parameters = cast(\n                    \"_CoreMultiExecuteParams\", effective_parameters\n                )\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_executemany:\n                        if fn(\n                            cursor,\n                            str_statement,\n                            effective_parameters,\n                            context,\n                        ):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_executemany(\n                        cursor,\n                        str_statement,\n                        effective_parameters,\n                        context,\n                    )\n            elif not effective_parameters and context.no_parameters:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute_no_params:\n                        if fn(cursor, str_statement, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_execute_no_params(\n                        cursor, str_statement, context\n                    )\n            else:\n                effective_parameters = cast(\n                    \"_CoreSingleExecuteParams\", effective_parameters\n                )\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute:\n                        if fn(\n                            cursor,\n                            str_statement,\n                            effective_parameters,\n                            context,\n                        ):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n>                   self.dialect.do_execute(\n                        cursor, str_statement, effective_parameters, context\n                    )\n\n.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1967: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fbfa6c98070>\ncursor = <cursor object at 0x7fbfa69b1d50; closed: -1>\nstatement = 'SELECT \"user\".id, \"user\".username, \"user\".currency, \"user\".firstname, \"user\".surname, \"user\".photo, \"user\".photo_small \\nFROM \"user\" \\nWHERE \"user\".username = %(username_1)s'\nparameters = {'username_1': 'Alex'}\ncontext = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fbfa671f880>\n\n    def do_execute(self, cursor, statement, parameters, context=None):\n>       cursor.execute(statement, parameters)\nE       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation \"user\" does not exist\nE       LINE 2: FROM \"user\" \nE                    ^\nE       \nE       [SQL: SELECT \"user\".id, \"user\".username, \"user\".currency, \"user\".firstname, \"user\".surname, \"user\".photo, \"user\".photo_small \nE       FROM \"user\" \nE       WHERE \"user\".username = %(username_1)s]\nE       [parameters: {'username_1': 'Alex'}]\nE       (Background on this error at: https://sqlalche.me/e/20/f405)\n\n.venv/lib/python3.10/site-packages/sqlalchemy/engine/default.py:951: ProgrammingError","flaky":true,"newFailed":false,"newBroken":true,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"[S]  Verify Url","time":{"start":1771689212459,"stop":1771689212459,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"[S] Base Url","time":{"start":1771689212459,"stop":1771689212459,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"[S] Pytestconfig","time":{"start":1771689212460,"stop":1771689212460,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"[S] Delete Output Dir","time":{"start":1771689212460,"stop":1771689212460,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"[S] Envs","time":{"start":1771689212460,"stop":1771689212463,"duration":3},"status":"passed","steps":[],"attachments":[{"uid":"48774c4041f09555","name":"envs.json","source":"48774c4041f09555.json","type":"application/json","size":511}],"parameters":[],"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},{"name":"[S] User Db","time":{"start":1771689212463,"stop":1771689212580,"duration":117},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"[S] Auth Client","time":{"start":1771689212580,"stop":1771689212580,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"[S] Registration User","time":{"start":1771689212580,"stop":1771689212604,"duration":24},"status":"broken","statusMessage":"sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation \"user\" does not exist\nLINE 2: FROM \"user\" \n             ^\n\n[SQL: SELECT \"user\".id, \"user\".username, \"user\".currency, \"user\".firstname, \"user\".surname, \"user\".photo, \"user\".photo_small \nFROM \"user\" \nWHERE \"user\".username = %(username_1)s]\n[parameters: {'username_1': 'Alex'}]\n(Background on this error at: https://sqlalche.me/e/20/f405)\n","statusTrace":"  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/pluggy/_callers.py\", line 38, in run_old_style_hookwrapper\n    res = yield\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/pluggy/_callers.py\", line 139, in _multicall\n    teardown.throw(exception)\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/_pytest/setuponly.py\", line 36, in pytest_fixture_setup\n    return (yield)\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/pluggy/_callers.py\", line 139, in _multicall\n    teardown.throw(exception)\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/pluggy/_callers.py\", line 53, in run_old_style_hookwrapper\n    return result.get_result()\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/pluggy/_result.py\", line 103, in get_result\n    raise exc.with_traceback(tb)\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/pluggy/_callers.py\", line 38, in run_old_style_hookwrapper\n    res = yield\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/pluggy/_callers.py\", line 121, in _multicall\n    res = hook_impl.function(*args)\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/_pytest/fixtures.py\", line 1202, in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/_pytest/fixtures.py\", line 915, in call_fixture_func\n    fixture_result = fixturefunc(**kwargs)\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/conftest.py\", line 168, in registration_user\n    user = user_db.get_user_by_username(envs.username)\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/database/user_db.py\", line 24, in get_user_by_username\n    return session.exec(user).first()\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlmodel/orm/session.py\", line 83, in exec\n    results = super().execute(\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py\", line 2351, in execute\n    return self._execute_internal(\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py\", line 2249, in _execute_internal\n    result: Result[Any] = compile_state_cls.orm_execute_statement(\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlalchemy/orm/context.py\", line 306, in orm_execute_statement\n    result = conn.execute(\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py\", line 1419, in execute\n    return meth(\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlalchemy/sql/elements.py\", line 526, in _execute_on_connection\n    return connection._execute_clauseelement(\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py\", line 1641, in _execute_clauseelement\n    ret = self._execute_context(\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py\", line 1846, in _execute_context\n    return self._exec_single_context(\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py\", line 1986, in _exec_single_context\n    self._handle_dbapi_exception(\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py\", line 2355, in _handle_dbapi_exception\n    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py\", line 1967, in _exec_single_context\n    self.dialect.do_execute(\n  File \"/home/runner/work/niffler-py-st3/niffler-py-st3/niffler-tests-python/.venv/lib/python3.10/site-packages/sqlalchemy/engine/default.py\", line 951, in do_execute\n    cursor.execute(statement, parameters)\n","steps":[],"attachments":[{"uid":"c3b74851458f7c88","name":"select niffler-userdata","source":"c3b74851458f7c88.txt","type":"text/plain","size":27},{"uid":"892267c1a2f10689","name":"select niffler-userdata","source":"892267c1a2f10689.txt","type":"text/plain","size":23},{"uid":"6fc8eec8a9ce7c6","name":"show niffler-userdata","source":"6fc8eec8a9ce7c6.txt","type":"text/plain","size":32},{"uid":"bbfed5949bfa1fd","name":"SELECT niffler-userdata","source":"bbfed5949bfa1fd.txt","type":"text/plain","size":161}],"parameters":[],"stepsCount":0,"shouldDisplayMessage":true,"attachmentsCount":4,"hasContent":true,"attachmentStep":false}],"afterStages":[],"labels":[{"name":"feature","value":"Страница Профиль"},{"name":"host","value":"runnervmwffz4"},{"name":"thread","value":"9130-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.ui_tests.test_profile"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"history":{"statistic":{"failed":2,"broken":1,"skipped":0,"passed":2,"unknown":0,"total":5},"items":[{"uid":"e8f291ddba4fe479","reportUrl":"https://AlexLumen.github.io/niffler-py-st3/43/#testresult/e8f291ddba4fe479","status":"failed","statusDetails":"AssertionError: Locator expected to have text 'learned_edited'\nActual value: learned \nCall log:\n  - Expect \"to_have_text\" with timeout 5000ms\n  - waiting for locator(\"[class*='css-14vsv3w']\").first\n    9 × locator resolved to <span class=\"MuiChip-label MuiChip-labelMedium css-14vsv3w\">learned</span>\n      - unexpected value \"learned\"","time":{"start":1771688295590,"stop":1771688302082,"duration":6492}},{"uid":"ab501217fc9efd71","reportUrl":"https://AlexLumen.github.io/niffler-py-st3/42/#testresult/ab501217fc9efd71","status":"passed","time":{"start":1771614450514,"stop":1771614452064,"duration":1550}},{"uid":"a412d7d4c7807895","reportUrl":"https://AlexLumen.github.io/niffler-py-st3/41/#testresult/a412d7d4c7807895","status":"failed","statusDetails":"AssertionError: Locator expected to have text 'gbp_edited'\nActual value: gbp \nCall log:\n  - Expect \"to_have_text\" with timeout 5000ms\n  - waiting for locator(\"[class*='css-14vsv3w']\").first\n    9 × locator resolved to <span class=\"MuiChip-label MuiChip-labelMedium css-14vsv3w\">gbp</span>\n      - unexpected value \"gbp\"","time":{"start":1771613448415,"stop":1771613454998,"duration":6583}},{"uid":"eea5aa4f7fd267f1","reportUrl":"https://AlexLumen.github.io/niffler-py-st3/40/#testresult/eea5aa4f7fd267f1","status":"passed","time":{"start":1771612810605,"stop":1771612812144,"duration":1539}}]},"tags":[]},"source":"f65afecf06c95127.json","parameterValues":[]}